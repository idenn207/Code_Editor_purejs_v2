<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor Performance Test</title>
  <link rel="stylesheet" href="styles/editor.css">
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, sans-serif;
      background: #1e1e1e;
      color: #fff;
    }
    #editor-container {
      width: 100%;
      height: 600px;
      border: 1px solid #444;
    }
    #stats {
      margin-top: 20px;
      padding: 15px;
      background: #2d2d2d;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    #stats h3 {
      margin: 0 0 10px 0;
      color: #4fc3f7;
    }
    #stats pre {
      margin: 5px 0;
      white-space: pre-wrap;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #444;
    }
    .stat-label { color: #aaa; }
    .stat-value { color: #4caf50; }
    .stat-warning { color: #ff9800; }
    .stat-error { color: #f44336; }
    #controls {
      margin-bottom: 20px;
    }
    button {
      padding: 8px 16px;
      margin-right: 10px;
      background: #4fc3f7;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #29b6f6;
    }
  </style>
</head>
<body>
  <h1>Editor Performance Test (1000 lines)</h1>

  <div id="controls">
    <button onclick="runPerformanceTest()">Run Input Test (100 chars)</button>
    <button onclick="clearStats()">Clear Stats</button>
    <button onclick="profileRender()">Profile Single Render</button>
  </div>

  <div id="editor-container"></div>

  <div id="stats">
    <h3>Performance Statistics</h3>
    <div id="stats-content">Click "Run Input Test" to start measuring...</div>
  </div>

  <script type="module">
    import { Editor } from './src/core/Editor.js';

    // Generate 1000 lines of JavaScript code
    function generate1000Lines() {
      const lines = [];
      for (let i = 0; i < 1000; i++) {
        const indent = '  '.repeat(i % 4);
        const templates = [
          `${indent}const variable${i} = ${i * 2};`,
          `${indent}function func${i}(a, b) { return a + b + ${i}; }`,
          `${indent}// Comment line ${i}`,
          `${indent}if (condition${i}) { console.log("line ${i}"); }`,
          `${indent}const obj${i} = { key: "value", num: ${i} };`,
          `${indent}for (let j = 0; j < ${i}; j++) { sum += j; }`,
          `${indent}class MyClass${i} extends BaseClass { }`,
          `${indent}const arr${i} = [1, 2, 3, ${i}];`,
          `${indent}async function async${i}() { await fetch(url); }`,
          `${indent}export const exported${i} = "${i}";`
        ];
        lines.push(templates[i % templates.length]);
      }
      return lines.join('\n');
    }

    // Create editor with 1000 lines
    const container = document.getElementById('editor-container');
    const editor = new Editor(container, {
      value: generate1000Lines(),
      language: 'javascript'
    });

    // Performance measurement storage
    const measurements = {
      renderTimes: [],      // _renderIncremental times
      tokenizeTimes: []     // _tokenizeAndRenderRange times
    };

    // Instrument EditorView for performance measurement
    const view = editor._view;
    const originalRenderIncremental = view._renderIncremental.bind(view);
    const originalTokenizeAndRenderRange = view._tokenizeAndRenderRange.bind(view);

    // Track incremental render times
    view._renderIncremental = function(change) {
      const start = performance.now();
      originalRenderIncremental(change);
      const end = performance.now();
      measurements.renderTimes.push(end - start);
      console.log(`[Perf] _renderIncremental: ${(end - start).toFixed(2)}ms (line ${change.startLine})`);
    };

    // Track tokenization times
    const origTokenize = view._tokenizeAndRenderRange.bind(view);
    view._tokenizeAndRenderRange = function(from, to, lines) {
      const start = performance.now();
      origTokenize(from, to, lines);
      const end = performance.now();
      measurements.tokenizeTimes.push(end - start);
      console.log(`[Perf]   Tokenize range ${from}-${to}: ${(end - start).toFixed(2)}ms`);
    };

    // Expose for global access
    window.editor = editor;
    window.measurements = measurements;

    // Run automated performance test
    window.runPerformanceTest = async function() {
      const statsEl = document.getElementById('stats-content');
      statsEl.innerHTML = 'Running test... typing 100 characters...';

      // Clear previous measurements
      Object.keys(measurements).forEach(key => measurements[key] = []);

      // Focus editor and move to middle of document
      editor._view.contentElement.focus();
      editor.setCursorPosition(500, 0);

      const inputTimes = [];
      const chars = 'abcdefghij'.repeat(10); // 100 characters

      console.clear();
      console.log('=== Starting Performance Test ===');
      console.time('Total Test Time');

      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        const inputStart = performance.now();

        // Simulate text input
        editor.insertText(char);

        const inputEnd = performance.now();
        inputTimes.push(inputEnd - inputStart);

        // Small delay to allow browser to process
        await new Promise(r => setTimeout(r, 10));
      }

      console.timeEnd('Total Test Time');
      console.log('=== Test Complete ===');

      // Calculate statistics
      const calcStats = (arr) => {
        if (arr.length === 0) return { avg: 0, min: 0, max: 0, total: 0 };
        const sum = arr.reduce((a, b) => a + b, 0);
        return {
          avg: sum / arr.length,
          min: Math.min(...arr),
          max: Math.max(...arr),
          total: sum
        };
      };

      const inputStats = calcStats(inputTimes);
      const renderStats = calcStats(measurements.renderTimes);
      const tokenStats = calcStats(measurements.tokenizeTimes);

      const getStatClass = (ms) => {
        if (ms > 100) return 'stat-error';
        if (ms > 50) return 'stat-warning';
        return 'stat-value';
      };

      statsEl.innerHTML = `
        <div class="stat-row">
          <span class="stat-label">Test: 100 characters typed on line 500 of 1000</span>
        </div>
        <hr style="border-color: #444; margin: 10px 0;">

        <div class="stat-row">
          <span class="stat-label">Input Time (insertText + render):</span>
          <span class="${getStatClass(inputStats.avg)}">
            avg: ${inputStats.avg.toFixed(2)}ms | min: ${inputStats.min.toFixed(2)}ms | max: ${inputStats.max.toFixed(2)}ms
          </span>
        </div>

        <div class="stat-row">
          <span class="stat-label">_renderIncremental():</span>
          <span class="${getStatClass(renderStats.avg)}">
            avg: ${renderStats.avg.toFixed(2)}ms | min: ${renderStats.min.toFixed(2)}ms | max: ${renderStats.max.toFixed(2)}ms
          </span>
        </div>

        <div class="stat-row">
          <span class="stat-label">  - Tokenization (affected lines only):</span>
          <span class="${getStatClass(tokenStats.avg)}">
            avg: ${tokenStats.avg.toFixed(2)}ms | min: ${tokenStats.min.toFixed(2)}ms | max: ${tokenStats.max.toFixed(2)}ms
          </span>
        </div>

        <hr style="border-color: #444; margin: 10px 0;">
        <div class="stat-row">
          <span class="stat-label">Total test time:</span>
          <span class="stat-value">${(inputStats.total).toFixed(0)}ms for 100 chars</span>
        </div>

        <div class="stat-row">
          <span class="stat-label">Average per keystroke:</span>
          <span class="${getStatClass(inputStats.avg)}">
            ${inputStats.avg.toFixed(2)}ms (target: < 16ms for 60fps)
          </span>
        </div>

        <div style="margin-top: 15px; color: #aaa; font-size: 11px;">
          <strong>Analysis:</strong><br>
          ${renderStats.avg > 16 ? '⚠️ Render time exceeds 16ms frame budget<br>' : '✅ Render time within 16ms frame budget<br>'}
          ${tokenStats.avg > 10 ? '⚠️ Tokenization taking significant time<br>' : '✅ Tokenization is fast<br>'}
          ${inputStats.avg < 16 ? '✅ Input latency is excellent (60fps capable)<br>' : ''}
          ${inputStats.avg < 50 ? '✅ Input latency is good<br>' : ''}
          ${inputStats.avg >= 50 && inputStats.avg < 100 ? '⚠️ Input latency is noticeable<br>' : ''}
          ${inputStats.avg >= 100 ? '❌ Input latency is too high<br>' : ''}
        </div>
      `;
    };

    window.clearStats = function() {
      Object.keys(measurements).forEach(key => measurements[key] = []);
      document.getElementById('stats-content').innerHTML = 'Stats cleared. Click "Run Input Test" to start measuring...';
    };

    window.profileRender = function() {
      console.log('=== Profiling Single Render ===');
      console.profile('SingleRender');

      console.time('Full Render');
      editor._view._render();
      console.timeEnd('Full Render');

      console.profileEnd('SingleRender');
      console.log('Check DevTools Performance tab for detailed breakdown');

      alert('Profile recorded. Check DevTools Console and Performance tab.');
    };

    console.log('Performance test loaded. Editor has 1000 lines.');
    console.log('Use runPerformanceTest() or click the button to start.');
  </script>
</body>
</html>
